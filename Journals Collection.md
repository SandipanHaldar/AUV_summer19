# Washington State University
A simulation  platform  wasdeveloped  using  the  Unity  Engine  for  verification  testing  toensure functionality before time sensitive testing within a realpool.
The bot used  four  depth  sensors,  four  IMUs  each  con-sisting of a 3-axis gyroscope, accelerometer, and magnetometer, four hydrophones, two front-facing stereoscopic cameras,one  bottom-facing  camera,  and  current,  voltage,  and  rpmsensors  embedded  in  each  of  the  8  thrusters.  All  sensor  datais  integrated  using  an  Unscented  Kalman  Filter  (UKF),  with a particle  filter  acting  as  an  intermediary  for  the  hydrophone and camera data.
Gyroscopes, Depth sensors, Embedded Thruster sensor, Accelerometer, Magnetometer are notable instruments used. 
The magnetometers targeted IIR notch filters have been ex-perimented with successfully to remove oscillations, a simpleFIR Low pass filter is sufficient, and provides a consistent timedelay  which  is  more  preferable. 
Now comes the stimulator part
* Sensors- Hardware  sensors  were  not  simulated  directly due to their complexity, but their outputs were matched using Unityâ€™s  built  in  3D  transforms.  Every  loop,  the  simulatedsensor module calculates the orientation of the submarine and outputs it to the software for processing. Noise can be added to  more  closely  simulate  bad  sensor  readings  depending  on observed noise within the real system.
* Thrusters:Thrusters  were  also  not  simulated  directly since fluid dynamics are too computationally expensive. However,  since  thrusters  were  linearized  in  the  real  system,  it  is assumed linear scaling of thruster values to the engine, making thruster simulation trivial. The thrusters are treated as a list of thrust  vectors  loaded  from  the  submarine  configuration  file.This  loads  the  offsets  of  the  thrusters  to  the  center  of  mass,their  orientations,  and  their  minimum  and  maximum  thrust.
* Cameras:Cameras were also not simulated directly due to  the  complexities  of  fish-eye  projection  and  lens  distortion.Fish-eye projection is also not supported in OpenGL or Unityand  must  be  done  manually  using  multiple  rectilinear  view-ports.  To  simplify,  since  cameras  are  calibrated,  undistorted,and  rectified  for  the  actual  system,  the  extrinsics  can  beloaded  to  place  cameras  in  the  same  location  and  projectionspace as the real submarine to recover the rectified coordinateframe. The vision pipeline then becomes identical as the realone barring re-projection errors within the original calibrationroutine.
* Submarine:Simulating the actual physics of the submarine was done much more directly than any other portion of the simulation. Since the Unity engine supports rigid body physics,mesh  rendering,  and  drag,  most  of  the  work  was  importing these  components  into  the  engine  using  approximations  from the original mechanical engineering designs. A visually representative rendering was done using a down-sampled mesh and texture  overlays  from  the  SolidWorks  model.  Statics  such  as the center of drag, mass, and buoyancy were also taken using SolidWorks  calculations  based  on  the  estimated  properties  of the submarine.  A simple  tensor  rotational/translational  drag  and  inertial  modelwas  made  that  could  closely  mimic  the  dynamics  of  the submarine in water without the complexities of fluid dynamics.
* Pool:Since the submarine can be tested in many different environments,  the  pool  simulation  is  just  as  important  as the  actual  submarine.  Pool  and  obstacle  simulation,  water reflections, fog rendering, lighting are all very complex problems  to  simulate  properly.  The  competition  pool  was  made using  Google  Earth  measurements  along  with  documented measurements of the geometry of the bottom. Obstacles were made  from  documents  as  well  and  can  be  placed  and  moved as needed once the final layout is measured at competition. All models were made using Google SketchUp and were imported to  the  engine  using  a  common  format.  Collision  meshes  and other scripted elements were generated once imported to allow entity interaction and debugging. To simulate water, the built-in  Unity  water  shaders  were  used  along  with  an  exponential fog  layer  in  the  camera  rendering  pipeline.  Lighting  is  also built  into  the  engine  and  can  be  adjusted  depending  the  timeof day and lighting conditions.  
